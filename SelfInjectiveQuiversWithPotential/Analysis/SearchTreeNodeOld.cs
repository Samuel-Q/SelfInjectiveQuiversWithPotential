using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SelfInjectiveQuiversWithPotential.Analysis
{
    /// <summary>
    /// This class represents a node in the search tree generated by
    /// <see cref="MaximalNonzeroEquivalenceClassRepresentativeComputerOld"/> when computing maximal
    /// nonzero equivalence class representatives for a semimonomial unbound quiver.
    /// Every node in said search tree represents a path, whose last vertex is <see cref="Vertex"/>
    /// and whose previous vertices are those of the path represented by <see cref="Parent"/> in a
    /// recursive manner (if <see cref="Parent"/> is <see langword="null"/>, the node represents
    /// the stationary path at <see cref="Vertex"/>).
    /// </summary>
    /// <typeparam name="TVertex">The type of the vertices of the quiver.</typeparam>
    [DebuggerDisplay("{GetDebuggerDisplayString(),nq}")] // nq for no quotes
    public class SearchTreeNodeOld<TVertex> where TVertex : IEquatable<TVertex>, IComparable<TVertex>
    {
        public TVertex Vertex { get; private set; }

        /// <summary>
        /// Gets the parent node, i.e., the node representing the subpath with the same source and
        /// with all but the last arrow of this node.
        /// </summary>
        public SearchTreeNodeOld<TVertex> Parent { get; private set; }

        internal Dictionary<TVertex, SearchTreeNodeOld<TVertex>> children;
        public IReadOnlyDictionary<TVertex, SearchTreeNodeOld<TVertex>> Children { get => children; }

        /// <summary>
        /// Gets the length of the path that this <see cref="SearchTreeNodeOld{TVertex}"/> represents.
        /// </summary>
        public int PathLengthInVertices { get; private set; }

        // This property plays two roles:
        //   1. Prevent infinite loops in the equivalence class search
        //   2. Prevent equivalence class search more than once
        // For performance reasons, this property may be false if the path is explored to be zero-
        // equivalent.
        // The guarantee is that if Explored is true, then the equivalence class is
        // either zero-equivalent or fully explored or have been encountered during the current
        // equivalence class search.
        public bool Explored { get; internal set; }

        /// <summary>
        /// Gets the node of origin for this node, which is defined as the node &quot;from which
        /// this node was discovered&quot;: either simply the parent or, if this node was
        /// discovered during an equivalence class search, the parent of the start node in that
        /// equivalence class search.
        /// </summary>
        /// <remarks>This property is used to check for cancellativity (or lack thereof).</remarks>
        public SearchTreeNodeOld<TVertex> Origin { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchTreeNodeOld{TVertex}"/> class.
        /// </summary>
        /// <param name="parent">The parent node, or <see langword="null"/> for the root node.</param>
        /// <param name="vertex">The last vertex in the path that this node represents.</param>
        public SearchTreeNodeOld(SearchTreeNodeOld<TVertex> parent, TVertex vertex, SearchTreeNodeOld<TVertex> origin)
        {
            Vertex = vertex;
            Parent = parent;
            children = new Dictionary<TVertex, SearchTreeNodeOld<TVertex>>();
            PathLengthInVertices = parent is null ? 1 : parent.PathLengthInVertices + 1;
            Explored = false;
            Origin = origin;
        }

        public IEnumerable<SearchTreeNodeOld<TVertex>> ReversePathOfNodes
        {
            get
            {
                var curNode = this;
                do
                {
                    yield return curNode;
                } while ((curNode = curNode.Parent) != null);
            }
        }

        /// <summary>
        /// Gets the sequence of arrows in the path in reverse order.
        /// </summary>
        /// <remarks>The arrows themselves are not reversed.</remarks>
        public IEnumerable<Arrow<TVertex>> ReversePathOfArrows
        {
            get
            {
                var curNode = this;
                while (curNode.Parent != null)
                {
                    yield return new Arrow<TVertex>(curNode.Parent.Vertex, curNode.Vertex);
                    curNode = curNode.Parent;
                }
            }
        }

        public IEnumerable<TVertex> ReversePathOfVertices
        {
            get
            {
                return ReversePathOfNodes.Select(x => x.Vertex);
            }
        }

        /// <remarks>This is slow.</remarks>
        public Path<TVertex> Path
        {
            get => new Path<TVertex>(PathOfVertices.ToArray());
        }

        /// <remarks>This is slower than <see cref="ReversePathOfArrows"/>.</remarks>
        public IEnumerable<Arrow<TVertex>> PathOfArrows
        {
            get => ReversePathOfArrows.Reverse();
        }

        /// <remarks>This is slower than <see cref="ReversePathOfVertices"/>.</remarks>
        public IEnumerable<TVertex> PathOfVertices
        {
            get => ReversePathOfVertices.Reverse();
        }

        private string GetDebuggerDisplayString()
        {
            return String.Join("->", PathOfVertices.Select(v => v.ToString()));
        }

        public override string ToString()
        {
            return GetDebuggerDisplayString();
        }
    }
}
