using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SelfInjectiveQuiversWithPotential.Analysis
{
    /// <summary>
    /// This class represents a node in the search tree generated by
    /// <see cref="MaximalNonzeroEquivalenceClassRepresentativeComputer"/> when computing maximal
    /// nonzero equivalence class representatives for a semimonomial unbound quiver.
    /// Every node in said search tree represents a path, whose last vertex is <see cref="Vertex"/>
    /// and whose previous vertices are those of the path represented by <see cref="Parent"/> in a
    /// recursive manner (if <see cref="Parent"/> is <see langword="null"/>, the node represents
    /// the stationary path at <see cref="Vertex"/>).
    /// </summary>
    /// <typeparam name="TVertex">The type of the vertices of the quiver.</typeparam>
    [DebuggerDisplay("{GetDebuggerDisplayString(),nq}")] // nq for no quotes
    public class SearchTreeNode<TVertex> where TVertex : IEquatable<TVertex>, IComparable<TVertex>
    {
        public TVertex Vertex { get; private set; }

        /// <summary>
        /// Gets the parent node, i.e., the node representing the subpath with the same source and
        /// with all but the last arrow of this node.
        /// </summary>
        public SearchTreeNode<TVertex> Parent { get; private set; }

        internal Dictionary<TVertex, SearchTreeNode<TVertex>> children;

        /// <summary>
        /// Gets the child nodes, i.e., the nodes representing paths that extend the path of this
        /// node.
        /// </summary>
        /// <remarks>
        /// <para>The returned dictionary does not necessarily contain nodes corresponding to paths
        /// that have never been encountered during the entire computation. Call </para>
        /// </remarks>
        public IReadOnlyDictionary<TVertex, SearchTreeNode<TVertex>> Children => children;

        /// <summary>
        /// Gets a value indicating whether the equivalence class of the node has been computed.
        /// </summary>
        /// <remarks>
        /// <para>If the node is zero-equivalent, this the value of this property is
        /// <see langword="true"/> despite the equivalence class being only partially computed.</para>
        /// </remarks>
        public bool EquivalenceClassIsComputed { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the node has been discovered during the equivalence
        /// class computation.
        /// </summary>
        /// <remarks>
        /// <para>Funky implementation to use <see cref="EquivalenceClassIsComputed"/> as a
        /// &quot;backing&quot; field but this saves precious memory.</para>
        /// </remarks>
        public bool HasBeenDiscoveredDuringEquivalenceClassComputation
        {
            get => EquivalenceClassIsComputed;
            set
            {
                EquivalenceClassIsComputed = value;
            }
        }

        /// <summary>
        /// Gets the length of the path (in arrows) that this
        /// <see cref="SearchTreeNode{TVertex}"/> represents.
        /// </summary>
        public int PathLength { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchTreeNode{TVertex}"/> class.
        /// </summary>
        /// <param name="parent">The parent node, or <see langword="null"/> for the root node.</param>
        /// <param name="vertex">The last vertex in the path that this node represents.</param>
        public SearchTreeNode(SearchTreeNode<TVertex> parent, TVertex vertex)
        {
            Vertex = vertex;
            Parent = parent;
            children = new Dictionary<TVertex, SearchTreeNode<TVertex>>();
            PathLength = parent is null ? 0 : parent.PathLength + 1;
        }

        public IEnumerable<SearchTreeNode<TVertex>> ReversePathOfNodes
        {
            get
            {
                var curNode = this;
                do
                {
                    yield return curNode;
                } while ((curNode = curNode.Parent) != null);
            }
        }

        /// <summary>
        /// Gets the sequence of arrows in the path in reverse order.
        /// </summary>
        /// <remarks>The arrows themselves are not reversed.</remarks>
        public IEnumerable<Arrow<TVertex>> ReversePathOfArrows
        {
            get
            {
                var curNode = this;
                while (curNode.Parent != null)
                {
                    yield return new Arrow<TVertex>(curNode.Parent.Vertex, curNode.Vertex);
                    curNode = curNode.Parent;
                }
            }
        }

        public IEnumerable<TVertex> ReversePathOfVertices
        {
            get
            {
                return ReversePathOfNodes.Select(x => x.Vertex);
            }
        }

        /// <remarks>This is slow.</remarks>
        public Path<TVertex> Path
        {
            get => new Path<TVertex>(PathOfVertices.ToArray());
        }

        /// <remarks>This is slower than <see cref="ReversePathOfArrows"/>.</remarks>
        public IEnumerable<Arrow<TVertex>> PathOfArrows
        {
            get => ReversePathOfArrows.Reverse();
        }

        /// <remarks>This is slower than <see cref="ReversePathOfVertices"/>.</remarks>
        public IEnumerable<TVertex> PathOfVertices
        {
            get => ReversePathOfVertices.Reverse();
        }

        private string GetDebuggerDisplayString()
        {
            return String.Join("->", PathOfVertices.Select(v => v.ToString()));
        }

        public override string ToString()
        {
            return GetDebuggerDisplayString();
        }
    }
}
