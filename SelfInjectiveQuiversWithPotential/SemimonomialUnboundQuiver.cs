using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SelfInjectiveQuiversWithPotential
{
    /// <summary>
    /// This class represents a semimonomial not-necessarily-bound quiver, i.e., a quiver equipped with a
    /// semimonomial ideal (generated by paths and differences of two paths) of the path algebra that
    /// is not necessarily admissible.
    /// </summary>
    /// <typeparam name="TVertex">The type of the vertices.</typeparam>
    public class SemimonomialUnboundQuiver<TVertex> where TVertex : IEquatable<TVertex>, IComparable<TVertex>
    {
        /// <summary>
        /// Gets the quiver.
        /// </summary>
        public Quiver<TVertex> Quiver { get; private set; }

        /// <summary>
        /// Gets the semimonomial ideal.
        /// </summary>
        public SemimonomialIdeal<TVertex> Ideal { get; private set; }

        public SemimonomialUnboundQuiver(Quiver<TVertex> quiver, SemimonomialIdeal<TVertex> ideal)
        {
            Quiver = quiver ?? throw new ArgumentNullException(nameof(quiver));
            Ideal = ideal ?? throw new ArgumentNullException(nameof(ideal));

            if (ideal.Paths.Any(path => !quiver.ContainsPath(path)))
                throw new ArgumentException($"The ideal contains a monomial generator not in the quiver.", nameof(ideal));

            if (ideal.DifferencesOfPaths.SelectMany(diff => new Path<TVertex>[] { diff.Minuend, diff.Subtrahend }).Any(path => !quiver.ContainsPath(path)))
                throw new ArgumentException($"The ideal contains a non-monomial generator one of whose paths is not in the quiver.");
        }

        public ISet<TVertex> Vertices { get => Quiver.Vertices; }

        /// <summary>
        /// Gets a dictionary mapping every vertex to its adjacency list (set), i.e., the list of arrows <em>starting</em> at the vertex.
        /// </summary>
        public IReadOnlyDictionary<TVertex, ISet<TVertex>> AdjacencyLists { get => Quiver.AdjacencyLists; }

        public IEnumerable<Arrow<TVertex>> GetArrows() => Quiver.Arrows;

        private IReadOnlyDictionary<TVertex, ISet<TVertex>> ConstructAdjacencyListDictionary(ISet<TVertex> vertices, IEnumerable<Arrow<TVertex>> arrows)
        {
            var tempDict = new Dictionary<TVertex, ISet<TVertex>>();
            foreach (var vertex in vertices)
            {
                tempDict[vertex] = new HashSet<TVertex>();
            }

            foreach (var arrow in arrows)
            {
                if (!(vertices.Contains(arrow.Source) && vertices.Contains(arrow.Target)))
                    throw new ArgumentException($"The arrow {arrow} has an endpoint not present in the vertex collection.");

                tempDict[arrow.Source].Add(arrow.Target);
            }

            var returnDict = new Dictionary<TVertex, ISet<TVertex>>();
            foreach (var arrow in tempDict.Keys)
            {
                returnDict[arrow] = tempDict[arrow];
            }

            return returnDict;
        }

        public bool Equals(SemimonomialUnboundQuiver<TVertex> otherQuiver)
        {
            if (otherQuiver is null) return false;

            if (!Quiver.Equals(otherQuiver.Quiver)) return false;
            if (!Ideal.Equals(otherQuiver.Ideal)) return false;

            return true;
        }

        public override bool Equals(object obj)
        {
            if (obj is SemimonomialUnboundQuiver<TVertex> otherQuiver) return Equals(otherQuiver);
            else return false;
        }

        public override int GetHashCode()
        {
            var hashCode = 100285057;
            hashCode = hashCode * -1521134295 + EqualityComparer<Quiver<TVertex>>.Default.GetHashCode(Quiver);
            hashCode = hashCode * -1521134295 + EqualityComparer<SemimonomialIdeal<TVertex>>.Default.GetHashCode(Ideal);
            return hashCode;
        }
    }
}