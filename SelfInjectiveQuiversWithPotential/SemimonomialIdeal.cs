using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SelfInjectiveQuiversWithPotential
{
    /// <summary>
    /// This class represents a semimonomial ideal of the path algebra a quiver, i.e., an ideal
    /// generated by paths and differences of two paths.
    /// </summary>
    /// <typeparam name="TVertex">The type of the vertices in the ideal.</typeparam>
    public class SemimonomialIdeal<TVertex> where TVertex : IEquatable<TVertex>, IComparable<TVertex>
    {
        /// <summary>
        /// Gets the monomial generators of the ideal.
        /// </summary>
        public IEnumerable<Path<TVertex>> Paths { get; private set; }

        /// <summary>
        /// Gets the non-monomial generators of the ideal.
        /// </summary>
        public IEnumerable<DifferenceOfPaths<TVertex>> DifferencesOfPaths { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SemimonomialIdeal{TVertex}"/> class.
        /// </summary>
        /// <param name="paths">The monomial generators of the ideal.</param>
        /// <param name="differencesOfPaths">The non-monomial generators of the ideal.</param>
        /// <exception cref="ArgumentNullException"><paramref name="paths"/> is <see langword="null"/>,
        /// or <paramref name="differencesOfPaths"/> is <see langword="null"/>.</exception>
        /// <exception cref="ArgumentException"><paramref name="paths"/> contains a duplicate path,
        /// or <paramref name="differencesOfPaths"/> contains a redundant difference of paths (i.e.,
        /// a duplicate difference of paths up to the equivalence relation of negating differences
        /// of paths).</exception>
        public SemimonomialIdeal(IEnumerable<Path<TVertex>> paths, IEnumerable<DifferenceOfPaths<TVertex>> differencesOfPaths)
        {
            if (paths is null) throw new ArgumentNullException(nameof(paths));
            if (differencesOfPaths is null) throw new ArgumentNullException(nameof(differencesOfPaths));

            if (paths.TryGetDuplicate(out var duplicate)) throw new ArgumentException($"{nameof(paths)} contains a duplicate path {duplicate}.");
            if (TryGetDuplicateDifference(differencesOfPaths, out var duplicateDifference))
                throw new ArgumentException($"{nameof(differencesOfPaths)} contains a redundant generator {duplicate}.");

            Paths = paths;
            DifferencesOfPaths = differencesOfPaths;

            bool TryGetDuplicateDifference(IEnumerable<DifferenceOfPaths<TVertex>> diffsOfPaths, out DifferenceOfPaths<TVertex> duplicateDiff)
            {
                var copy = new HashSet<DifferenceOfPaths<TVertex>>();
                foreach (var d in diffsOfPaths)
                {
                    if (copy.Contains(d) || copy.Contains(d.Negate()))
                    {
                        duplicateDiff = new DifferenceOfPaths<TVertex>(d.Minuend, d.Subtrahend);
                        return true;
                    }
                }

                duplicateDiff = default;
                return false;
            }
        }
    }
}
